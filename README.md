1. Write a function curry that takes a function and curried arguments and returns a new function that can take the remaining arguments.

2. Implement a function deepFlatten that takes a deeply nested array and flattens it.

3. Create a debounce function that limits the execution of a function call and waits for a certain amount of time before running it again.

4. Write a throttle function that ensures a given function is only called at most once in a specified time period.

5. Write a function chunk that splits an array into subarrays of specified length.

6. Create a function deepEqual that compares two values deeply, checking if they are equal in value and structure.

7. Implement your own bind function that replicates the functionality of JavaScript's native Function.prototype.bind.

8. Write a function unique that returns a new array with only the unique elements from the original array.

9. Implement a function intersection that finds the intersection of two arrays, returning an array with elements that appear in both.

10. Write a custom filter function that mimics the behavior of the native Array.prototype.filter method.

11. Create your own version of the reduce method called myReduce that mimics the behavior of the native Array.prototype.reduce.

12. Write a function permute that returns all possible permutations of the elements in an array.

13. Implement a function rotateArray that rotates an array to the right by a given number of steps.

14. Write a function isBalanced that takes a string containing only parentheses and checks if they are balanced.

15. Create a function mergeIntervals that merges all overlapping intervals in an array of interval pairs.

16. Implement a function nestedSum that calculates the sum of all numbers in a nested array, regardless of how deep the array is.

17. Implement a function calcLetters that calculates and resturns the sum of all repeated characters in an strings.
    Ex: input => "Apple"
    outout => {"A":1, "e":1, "l":1, "p":2}
